<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>mysql | zuolinlin</title>
<link rel="shortcut icon" href="https://zuolinlin.github.io/zuo.github.io//favicon.ico?v=1654385274636">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://zuolinlin.github.io/zuo.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="mysql | zuolinlin - Atom Feed" href="https://zuolinlin.github.io/zuo.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="mysql
目录


mysql基础架构

mysql架构设计
InnoDB存储引擎的架构设计

[buffer pool](#buffer pool)
[redo log](#redo log)
[undo log](#undo log)..." />
    <meta name="keywords" content="数据库" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://zuolinlin.github.io/zuo.github.io/">
  <img class="avatar" src="https://zuolinlin.github.io/zuo.github.io//images/avatar.png?v=1654385274636" alt="">
  </a>
  <h1 class="site-title">
    zuolinlin
  </h1>
  <p class="site-description">
    你要问我如何去二仙桥，我会告诉你走成华大道。可你要问人生，我也说不清。
  </p>
  <div class="menu-container">
    
      
        <a href="https://zuolinlin.github.io/zuo.github.io/" class="menu">
          首页
        </a>
      
    
      
        <a href="https://zuolinlin.github.io/zuo.github.io/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://zuolinlin.github.io/zuo.github.io/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://zuolinlin.github.io/zuo.github.io/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              mysql
            </h2>
            <div class="post-info">
              <span>
                2022-04-08
              </span>
              <span>
                77 min read
              </span>
              
                <a href="https://zuolinlin.github.io/zuo.github.io/tag/bw-eCiZ9Q/" class="post-tag">
                  # 数据库
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp3.itc.cn%2Fimages01%2F20210618%2Fb98b327e2bd041728ee2476fa528aa66.png&amp;refer=http%3A%2F%2Fp3.itc.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652016948&amp;t=798e6972b9143757cf5dabb3c94f4c3e" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="mysql">mysql</h1>
<h2 id="目录">目录</h2>
<ul>
<li>
<p><a href="#Mysql%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84">mysql基础架构</a></p>
<ul>
<li><a href="#Mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">mysql架构设计</a></li>
<li><a href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">InnoDB存储引擎的架构设计</a>
<ul>
<li>[buffer pool](#buffer pool)</li>
<li>[redo log](#redo log)</li>
<li>[undo log](#undo log)</li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E5%8A%A1">事务</a>
<ul>
<li><a href="#%E5%A4%9A%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E6%88%96%E8%80%85%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98">多事务并发更新或者查询的数据问题</a>
<ul>
<li><a href="#%E8%84%8F%E5%86%99">脏写</a></li>
<li><a href="#%E8%84%8F%E8%AF%BB">脏读</a></li>
<li><a href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">不可重复读</a></li>
<li><a href="#%E5%B9%BB%E8%AF%BB">幻读</a></li>
</ul>
</li>
<li><a href="#SQL%E6%A0%87%E5%87%86%E4%B8%AD%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%844%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">SQl对事务的四种隔离级别</a>
<ul>
<li><a href="#%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4">read uncommitted</a></li>
<li><a href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4">read committed</a></li>
<li><a href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">repeatable</a></li>
<li><a href="#%E4%B8%B2%E8%A1%8C%E5%8C%96">serializable</a></li>
</ul>
</li>
<li><a href="#%E9%80%8F%E5%BD%BB%E5%89%96%E6%9E%90Mysql%E7%9A%84MVCC%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6">透彻剖析Mysql的MVCC事务隔离机制</a>
<ul>
<li>[undo log版本链](#Undo log版本链)</li>
<li><a href="#ReadView%E6%9C%BA%E5%88%B6">ReadView机制</a></li>
<li>[Read Committed隔离级别是如何基于ReadView机制实现的？](#Read Committed隔离级别是如何基于ReadView机制实现的？)</li>
<li><a href="#MySQL%E6%9C%80%E7%89%9B%E7%9A%84RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EReadView%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F">MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E4%B8%AA%E4%BA%8B%E5%8A%A1%E6%9B%B4%E6%96%B0%E5%90%8C%E4%B8%80%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E9%94%81%E9%81%BF%E5%85%8D%E8%84%8F%E5%86%99%E7%9A%84%EF%BC%9F">多个事务更新同一行数据时，是如何加锁避免脏写的？</a>
<ul>
<li><a href="#%E5%85%B1%E4%BA%AB%E9%94%81">共享锁</a></li>
<li><a href="#%E7%8B%AC%E5%8D%A0%E9%94%81">独占锁</a></li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95">索引</a>
<ul>
<li><a href="#%E7%A3%81%E7%9B%98%E4%B8%8A%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">磁盘上数据页的存储结构</a></li>
<li><a href="#%E9%A1%B5%E5%88%86%E8%A3%82%E7%9A%84%E8%BF%87%E7%A8%8B">页分裂的过程</a></li>
<li><a href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95">主键索引</a></li>
<li><a href="#B+%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%B4%A2%E5%BC%95%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">B+树实现索引的物理结构</a></li>
<li><a href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">聚簇索引</a></li>
<li><a href="#%E9%92%88%E5%AF%B9%E4%B8%BB%E9%94%AE%E4%B9%8B%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86">针对主键之外的其他字段建立索引的原理</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">索引的优缺点</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99">索引的使用规则</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%99">索引的设计规则</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">执行计划</a></li>
<li><a href="#sql%E8%B0%83%E4%BC%98">sql调优</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mysql%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">mysql数据模型</a>
<ul>
<li><a href="#VARCHAR%E8%BF%99%E7%A7%8D%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84">VARCHAR这种变长字段，在磁盘上到底是如何存储的</a></li>
<li><a href="#%E4%B8%80%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AANULL%E5%AD%97%E6%AE%B5%E5%80%BC%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%EF%BC%9F">一行数据中的多个NULL字段值在磁盘上怎么存储？</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E4%B8%AD40%E4%B8%AAbit%E4%BD%8D%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%B4%E4%BB%A5%E5%8F%8A%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9F">磁盘文件中40个bit位的数据头以及真实数据是如何存储的？</a></li>
<li><a href="#%E8%A1%8C%E6%BA%A2%E5%87%BA">行溢出</a></li>
<li><a href="#%E8%A1%A8%E7%A9%BA%E9%97%B4">表空间</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5">生产实践</a></p>
<ul>
<li><a href="#%E7%9C%9F%E5%AE%9E%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%BA%E5%99%A8%E9%85%8D%E7%BD%AE%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%EF%BC%9F">真实生产环境下的数据库机器配置如何规划？</a></li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%EF%BC%9F%EF%BC%9F">互联网公司的生产环境数据库是如何进行性能测试的？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C360%E5%BA%A6%E6%97%A0%E6%AD%BB%E8%A7%92%E5%8E%8B%E6%B5%8B%EF%BC%9F">如何对生产环境中的数据库进行360度无死角压测？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%B8%BA%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E7%BD%B2%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%EF%BC%9F">如何为生产环境中的数据库部署监控系统？</a></li>
<li>[如何通过多个Buffer Pool来优化数据库的并发性能？](#如何通过多个Buffer Pool来优化数据库的并发性能？)</li>
<li>[如何通过chunk来支持数据库运行期间的Buffer Pool动态调整？](#如何通过chunk来支持数据库运行期间的Buffer Pool动态调整？)</li>
<li>[在生产环境中，如何基于机器配置来合理设置Buffer Pool？](#在生产环境中，如何基于机器配置来合理设置Buffer Pool)</li>
<li><a href="#Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%B1%82%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8AIO%E8%B0%83%E5%BA%A6%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86">Linux操作系统的存储系统软件层原理剖析以及IO调度优化原理</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84RAID%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E5%88%9D%E6%AD%A5%E4%BB%8B%E7%BB%8D">数据库服务器使用的RAID存储架构初步介绍</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84RAID%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%94%B5%E6%B1%A0%E5%85%85%E6%94%BE%E7%94%B5%E5%8E%9F%E7%90%86">数据库服务器上的RAID存储架构的电池充放电原理</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%95%85%E9%9A%9C%E7%9A%84%E5%AE%9A%E4%BD%8DToomanyconnections">数据库无法连接故障的定位，Too many connections</a></li>
<li><a href="#%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E6%80%A7%E8%83%BD%E6%8A%96%E5%8A%A8%E4%BC%98%E5%8C%96">线上数据库不确定性的性能抖动优化</a></li>
</ul>
</li>
<li>
<p><a href="#mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84">mysql主从架构</a></p>
<ul>
<li><a href="#%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8E%9F%E7%90%86">主从架构的原理</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA">主从复制架构的搭建</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98">主从复制数据延迟问题</a></li>
<li><a href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84">高可用架构</a></li>
<li><a href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">分库分表</a></li>
</ul>
</li>
</ul>
<h1 id="目录-2">目录</h1>
<h2 id="mysql基础架构">Mysql基础架构</h2>
<h3 id="mysql架构设计">Mysql架构设计</h3>
<p>一个不变的原则：网络连接必须让线程处理 mysql架构的整体设计原理<br>
<img src="image/mysqlshejiyuanli.png" alt="img_1.png" loading="lazy"></p>
<h3 id="innodb存储引擎的架构设计">InnoDB存储引擎的架构设计</h3>
<figure data-type="image" tabindex="1"><img src="image/InnoDByuanlli.png" alt="img.png" loading="lazy"></figure>
<p>实际上，执行器是非常核心的一个组件，负责跟存储引擎配合完成一个sql语句在磁盘与内存层面的全部数据更新操作。</p>
<p>拆分成两个阶段：</p>
<p>上图的1，2，3，4是执行更新语句的时候干的事， 5，6是从你提交事务开始的，属于提交事务阶段</p>
<pre><code>redo log 是一种偏向物理性值的重做日志，本身属于InnoDB存储引擎特有的一个东西。

redo log 主要记录下你对数据做了哪些修改，这个此时还在内存缓存区

bin log 叫做归档日志，它里面记录的时偏向逻辑性的日志，类似  对users 表中的id =10的一行数据，进行了更新操作，操作以后的值是什么   

bin log 日志不是InnoDB 存储引擎特意的日志文件，是属于 mysql server 自己的日志文件
</code></pre>
<p>提交事务时，redo log日志的刷盘策略：</p>
<pre><code>  这个策略通过innodb_flush_log_at_trx_commit 来配置
  0：提交事务的时候，不会把redo log buffer 里的数据刷入磁盘文件，此时你可能提交事务了，结果mysql宕机了，此时内存中的数据全部丢失。
  1：提交事务的时候，就必须把redo log 从内存中刷入到磁盘文件里去，只要事务提交成功，那么redo log 就必然在磁盘里。
  2：提交事务的时候，把redo日志写入磁盘文件对应的os cache缓存里去，而不是直接进入磁盘文件，可能1s之后才会把os cache里的数据写入到磁盘文件
</code></pre>
<p>对于数据库这种严格的系统而言，一般建议redo 日志刷盘策略设置为1，保证事务提交之后，数据绝对不能丢失</p>
<p>提交事务时，bin log日志的刷盘策略：</p>
<pre><code>  这个策略通过sync_binlog参数来控制binlog的刷盘策略，它的默认值是0
  0:提交事务的时候，新进入 os cache 内存缓存，后刷回到磁盘（bin log会丢失）
  1:提交事务的时候，强制把binlog直接写入磁盘文件里去（bin log不会丢失）
</code></pre>
<h4 id="buffer-pool">buffer pool</h4>
<figure data-type="image" tabindex="2"><img src="image/bufferpool.png" alt="img_1.png" loading="lazy"></figure>
<p>数据库buffer pool 里面会包含很很多个缓存页，同时每个缓存页还有一个数据描述，也可以叫做数据控制</p>
<p>初始化buffer pool</p>
<pre><code>数据库只要已启动，就会按照你设置的buffer pool 的大小稍微再加大一点去找操作系统申请一块内存区域，作为buffer pool的内存区域

然后当内存区域申请完毕之后，数据库就会按照默认的缓存页的16kb的大小以及对应800个字节左右的描述数据的大小，在buffer pool 中划分出来一个个缓存页和一个个对应的数据描述

只不过这个时候，buffer pool中一个个缓存页的都是空的，里面什么都没有，要等数据库运行起来，我们对数据进行增删改查的操作的时候，才会把数据对应的磁盘文件读取出来，放入buffer pool 的缓存页
</code></pre>
<p>哪些缓存页是空闲的？ free链表</p>
<p>从磁盘上的数据页放入到buffer pool的缓存页，必然涉及到一个问题，那就是哪些缓存页是空闲的？</p>
<pre><code>所以数据库会为buffer pool 设计一个**free链表**，它是一个双向链表的数据结构，这个free链表里，每个节点就是一个空闲的
缓存页的描述数据块的地址，也就是说，只要你的一个缓存页是空闲的，那么它的描述数据块地址就会被放入free链表中。
</code></pre>
<p>磁盘上的数据页是如何读到缓存页中？</p>
<pre><code> 其实有了free链表之后，这个问题就很简单了，首先需要重free链表中获取描述数据块，然后就可以获取这个描述数据块对应的空闲缓存页
 写缓存页，添加描述信息
</code></pre>
<p>那怎么知道一个数据是否加载到缓存页？</p>
<pre><code>数据库会维护一个**哈希表数据结构**，他会用表空间+数据页号作为key，然后缓存的地址作为value

也就是说每次你读取一个数据页缓存之后，都会在这个哈希表中写入一个key-value，下次在使用数据页只需要从哈希表中读取数据即可 
</code></pre>
<p>哪些缓存页是脏页</p>
<pre><code>内存中更新的脏页数据，都是要被刷回磁盘文件的。
但是不肯呢个所有的缓存页都刷回磁盘，因为有的缓存页可能是因为查询的时候，而被读到buffer pool 里面去的，可能根本没有修改过

所以数据库这里引入了另外一个跟free链表类似的**flush 链表**，**这个flush链表的本质也是通过缓存页的描述数据块的两个指针，让被修改过的缓存页描述数据块组成一个双向链表**
</code></pre>
<p>引入LRU算法来判断哪些缓存页是不常用的（缓存命中率）</p>
<pre><code>怎么判断哪些缓存页不是经常使用，哪些缓存页是脏页？
引入LRU链表

LRU：least recently used 最近最少使用的意思

工作原理：

假如我们从磁盘加载一个数据页到缓存页的时候，就会把这个缓存页描述数据放到LRU的头部，
那么只要有数据缓存页的时候，他就会在LRU链表里，而且最近被在加载的缓存页，都会放到
LRU的头部去。

然后假定某个缓存页的描述数据块本来是放在LRU尾部，后续你只要查询或者修改了这个缓存页的数据，也要把这个缓存页挪动到HttpServletRequest
尾部，也就是说最近被访问过的缓存页，一定在LRU的头部。
</code></pre>
<p>LRU算法带来的问题</p>
<pre><code>预读带来的巨大问题

预读会导致，一直没被访问的数据放在LRU链表的头部，在空闲缓存页全部使用完时，会将链表尾部的数据刷入磁盘，清空缓存页。但是有可能这个数据时经常被使用的
</code></pre>
<p>哪些情况会触发Mysql的预读机制</p>
<pre><code>1.innodb_read_ahead_threshold他的默认值是56，意思是就是如果顺序的访问一个区里的多个数据页，访问的数据页的数量可能超过这个阈值
此时就会触发预读机制，把下一个相邻区中所有额数据页都加载到缓存中去。

2.如果Buffer Pool里缓存了12个联系的数据页，而且这些数据都是比较频繁被访问的，此时就会出发预读机制，把这个区里的其他数据页都加载到缓存里区。
这个机制是通过参数innodb_random_read_ahead来控制的，默认时OFF，也就是这个规则是关闭的
</code></pre>
<p>另外一种可能导致频繁访问的缓存页被淘汰的场景体验一下</p>
<p>那就是<strong>全表扫描</strong></p>
<pre><code>  类似  SELECT * FROM USERS 他一下子吧这个表里的所有数据页，都加载到Buffer Pool里去
</code></pre>
<p>Mysql基于冷热数据分离方案优化LRU算法</p>
<pre><code>真正的LRU链表，会被拆分成两个部分,一个部分是热数据，一个部分是冷数据，这个冷数据比例是由

innodb_old_blocks_pct参数来控制的，它默认的是37，也就是说冷数据的占比37%。

实际上这个时候，第一次加载时，缓存页会被放到冷数据链表的头部。
</code></pre>
<p>冷数据区域的缓存页何时被加载到热数据区域</p>
<pre><code>innodb_old_blocks_time 默认设置为1000，也就是1000毫秒

也就是数据加载到冷数据区域，过了1s后，你再访问这个缓存页，他就会被放到热数据区域的链表头部
</code></pre>
<figure data-type="image" tabindex="3"><img src="image/LRU.png" alt="img.png" loading="lazy"></figure>
<p>LRU链表的热数据区域是如何进行优化的？</p>
<pre><code>经常被访问的数据时热数据，不经常被访问的数据是冷数据，所以在设计缓存的时候，经常会考虑 **热数据的缓存预加载**
也就是说，每天统计出来哪些商品被访问次数最多，然后晚上的时候，系统启动一个定时作业，把热门商品的数据，预加载到redis里。
那么第二页是不是对热门访问的商品自然就优先走redis

 LRU链表的热数据区域的访问规则被优化了一下，即你只要在热数据区域的后3/4部分缓存页被访问了，才会给你移动到链表头部

如果你是热数据区域的前面的1/4的缓存页被访问，他是不会移动到链表头部的。

这样可以尽可能减少链表中的节点移动了。
</code></pre>
<p>定时LRU尾部的部分缓存页刷入磁盘</p>
<pre><code>第一个时机：有一个后台线程，他会运行一个定时任务，这个定时任务每个一段时间，就会把LRU链表的冷数据区域的尾部一些缓存页刷入到磁盘里去，清空几个缓存页，把他们加入到free链表中。

只要缓存页被刷盘，那么这个缓存页必然会加搭配free链表中，从flush链表中一处，从LRU链表中移除。

因为LRU链表中的热数据可能是被频繁修改的，难道他们永远都不刷入到磁盘了吗？

第二个时机，这个后台线程同时也会在Mysql不怎么繁忙的时候，找个时间把flush链表中的缓存页刷入磁盘，这样被你修改过的数据迟早都会刷入磁盘。
</code></pre>
<h4 id="redo-log">redo log</h4>
<p>redo log:在事务提交成功之后，保存一条日志记录，防止机器宕机导致数据丢失。顺序写，性能高。</p>
<p>redo log长什么样？</p>
<pre><code>redo log里面记录的就是：**表空间号+数据页号+偏移量+修改了几个字节的值+具体的值**

修改了几个字节的值，redo log就划分了不同的类型，MLOG_1BYTE:就是修改了一个字节的值，以此类推
但是如果你修改了一大串的值，类型就是MLOG_WRITE_STRING,就是代表你一下子在那个数据页的某个偏移量位置插入或者修改了一大串的值

日志类型(就是类似MLOG_1BYTE)，表空间号，数据页号，数据页中的偏移量。具体修改的数据
</code></pre>
<p>redo log写磁盘的过程</p>
<pre><code>其实mysql内有另外一个数据结构，叫做 redo log block
一个 redo log block是512字节，这个redo log block字节分为三个部分
一个是12字节的header块头，一个是496字节的body块体，一个是4字节trailer块尾
在这里面，12个字节的header投又分为4个部分：
    1.包括4个字节的block no，就是块唯一编码
    2.2个字节的data length，就是block里写入了多个字节数据；
    3.2个字节的first record group ，这个是说每个事务都会有多个redo log ，一个是redo log group，另一组redo log。那么在这个block里的第一组redo log的偏移量，就是这两个字节存储的；
    4.4个字节的checkpoint on
</code></pre>
<figure data-type="image" tabindex="4"><img src="image/redolog.png" alt="img.png" loading="lazy"></figure>
<p>redo log block 与磁盘文件的关系</p>
<figure data-type="image" tabindex="5"><img src="image/redo_log_block2.png" alt="img.png" loading="lazy"></figure>
<p>平时我们执行完增删改之后，要写入磁盘的redo log，其实应该是先进入到redo log block这个数据结构里，然后再进入磁盘文件</p>
<p>redo log buffer 类似申请出一块连续的空间，然后里面划分出N多个空的redo log block</p>
<p>通过设置mysql的innodb_log_buffer_size可以指定这个redo log buffer的大小，默认也就是16MB</p>
<figure data-type="image" tabindex="6"><img src="image/redo_log_block3.png" alt="img_1.png" loading="lazy"></figure>
<p>redo log buffer中的缓冲日志，到底是什么时候写入磁盘的？</p>
<pre><code>（1）如果写入redo log buffer的日志已经占据了redo log buffer总容量的一半了，也就是超过了8MB的redo log在
缓冲里了，此时就会把他们刷入到磁盘文件里去
（2）一个事务提交的时候，必须把他的那些redo log所在的redo log block都刷入到磁盘文件里去，只有这样，当事
务提交之后，他修改的数据绝对不会丢失，因为redo log里有重做日志，随时可以恢复事务做的修改
（PS：当然，之前最早最早的时候，我们讲过，这个redo log哪怕事务提交的时候写入磁盘文件，也是先进入os cache的，进入os的
文件缓冲区里，所以是否提交事务就强行把redo log刷入物理磁盘文件中，这个需要设置对应的参数，我们之前都讲过的 ，大家回过
头去看看 ）
（3）后台线程定时刷新，有一个后台线程每隔1秒就会把redo log buffer里的redo log block刷到磁盘文件里去
（4）MySQL关闭的时候，redo log block都会刷入到磁盘里去
</code></pre>
<p>redo log占用磁盘越来越大怎么办？</p>
<p>实际上默认情况下，redo log都会写入到一个目录中文件按里，这个目录可以通过</p>
<pre><code>show variables like 'datadir'
</code></pre>
<p>可以通过修改</p>
<pre><code>innodb_log_group_home_dir
</code></pre>
<p>参数来设置redo log这个目录</p>
<p>指定每个redo log文件的大小，默认是48M</p>
<pre><code>innodb_log_file_size
</code></pre>
<p>指定日志文件的数量</p>
<pre><code>innodb_log_file_in_group
</code></pre>
<figure data-type="image" tabindex="7"><img src="image/redologsetting.png" alt="img.png" loading="lazy"></figure>
<h4 id="undo-log">undo log</h4>
<p>INSERT 语句的undo log 类型是TRX_UNDO_INSERT_REC ，这个undo log里包含了一下的东西：</p>
<pre><code>    1.这条日志的开始位置
    2.主键的各列长度和值
    3.表idx
    4.undo log 日志编号
    5.undo log 日志类型
    6.这条日志的结束位置
</code></pre>
<figure data-type="image" tabindex="8"><img src="image/undolog.png" alt="img.png" loading="lazy"></figure>
<p>现在事务要是回滚，直接从undo log 日志中拿出这个id，找到对应的数据删掉</p>
<h3 id="事务">事务</h3>
<h4 id="多事务并发更新或者查询的数据问题">多事务并发更新或者查询的数据问题</h4>
<p>多个事务要是对缓存页里的同一条数据同时进行更新或者查询，此时会产生哪些问题？</p>
<pre><code>  实际上会设计到脏读，脏写，不可重复读，幻读
</code></pre>
<h5 id="脏写">脏写</h5>
<pre><code>事务B修改了事务A修改过的值，此时事务A还没提交，所以事务A随时会回滚，导致事务B修改过的值也没了
</code></pre>
<figure data-type="image" tabindex="9"><img src="image/zangxie.png" alt="img.png" loading="lazy"></figure>
<h5 id="脏读">脏读</h5>
<pre><code>事务B查询了事务A修改过的数据，但是此时事务A还没有提交，所以事务A随时回滚，导致事务B再次查询就读不到事务A修改的数据了
</code></pre>
<figure data-type="image" tabindex="10"><img src="image/zangdu.png" alt="img.png" loading="lazy"></figure>
<p>其實一句话总结：</p>
<pre><code>无论是脏写还是脏读，都是因为一个事务去更新或者查询了另外一个还没有提交的事务更新过的数据
    
因为另外一个事务还没提交，所以他随时可能反悔回滚，那么必然导致你更新的数据没了，或者你之前查询到的数据就没了，这种就是脏读和脏写。
</code></pre>
<h5 id="不可重复读">不可重复读</h5>
<pre><code>   针对已经提交的事务修改的值，被你的事务给读到了，你的事务多次查询，多次读到的是别人已经提交事务
   修改过的值，导致每次查询的值不一样
</code></pre>
<figure data-type="image" tabindex="11"><img src="image/bukechongfudu.png" alt="img_1.png" loading="lazy"></figure>
<h5 id="幻读">幻读</h5>
<h4 id="sql标准中对事务的4个隔离级别">SQL标准中对事务的4个隔离级别</h4>
<p>SQL标准中滚定了4种事务隔离级别，并不是Mysql的事务隔离级别，mysql的事务隔离级别有点差别。</p>
<p>在SQL标准中，规定的4种事务隔离级别，就是说多个事务并发运行的同时，互相是如何隔离的，从而避免事务并发问题</p>
<p>这四种级别包括：</p>
<h5 id="read-uncommitted-读未提交是不允许脏写的">read uncommitted 读未提交：是不允许脏写的</h5>
<pre><code>也就是说，不可能两个事务在没有提交的情况下去更新同一行数据的值，
但是这种隔离级别下，可能发生脏读，不可重复度，幻读。
</code></pre>
<h5 id="read-committed-rc-读已提交不可能发生脏写和脏读">read committed  RC 读已提交：不可能发生脏写和脏读</h5>
<pre><code>也就是说人家事务没有提交修改的值，你是绝对读不到的
这种隔离级别下不会发生脏读和脏写，但是可以发生不可重复读和幻读
</code></pre>
<h5 id="repeatable-read-rr-可重复读不可能发生脏读脏写不可重复读">repeatable read RR 可重复读：不可能发生脏读脏写，不可重复读</h5>
<pre><code>你的事务多次查询一个数据的值，哪怕别的事务修改这个值还提交了，没有，你不会读到人家事务提交事务修改过的值
你的事务一旦开始，多次查询一个值，会一直读到同一个值。
</code></pre>
<h5 id="serializable-串行化">serializable 串行化</h5>
<pre><code> 这种隔离级别，根本不允许你多个事务并发执行，只能串起来执行
</code></pre>
<h4 id="spring对事务的支持">spring对事务的支持</h4>
<p>在@Transaction(isolation =isolation.DEFAULT),默认是default，表示数据库是什么就是什么 isolation.READ_UNCOMMITTED isolation.READ_COMMITTED<br>
isolation.REPEATABLE_READ isolation.SERIALIZABLE</p>
<h4 id="透彻剖析mysql的mvcc事务隔离机制">透彻剖析Mysql的MVCC事务隔离机制</h4>
<h5 id="undo-log版本链">Undo log版本链</h5>
<pre><code>我们每条数据其实都有两个隐藏字段，一个是trx_id,一个是roll_pointer ，
這個trx_id就是最近一次更新过这条数据的事务id，
roll_pointer 就是指向你了你更新这个事务之前生成的undo log。
所以不管多个事务并发执行时如何执行的，
起码先搞清楚一点，就是多个事务串行执行的时候，每个人修改了一行数据，都会更新隐藏字段trx_id和roll_pointer，
同时之前多个数据快照对应的undo log，会通过roll_pointer指针串联起来，形成一个很重要的版本链
</code></pre>
<h5 id="readview机制">ReadView机制</h5>
<p><a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/i_5e86040203a20_GmWrGMJe/1?from=p_5e0c2a35dbbc9_MNDGDYba&amp;type=6">ReadView机制</a></p>
<p>你在在执行事务的时候，就会生成一个ReadView，里面比较重要的东西有四个</p>
<pre><code>1.一个是m_ids，这个就是说此时有哪些事务在mysql里执行还没有提交的
2.一个是min_trx_id，就是m_ids里最小的值；
3.一个是max_trx_id,这是说mysql下一个要生成的事务id，就是最大的事务id
4.一个是create_trx_id，就是你这个事务的id
</code></pre>
<p>现在两个事务并发执行过来，一个是事务A（id = 45），一个是事务B（id = 59），事务B要更新这行数据<br>
事务A是要去读取这行数据的值</p>
<p>现在事务A直接开启ReadView，这个ReadView里的m_ids就包含事务A和事务B的两个id，45和59，<br>
然后min_trx_id就是45，max_trx_id 就是60 create_trx_id 就是45 是事务A自己</p>
<p>这个时候事务A第一次查询这行数据，会走一个判断，就是判断这行数据的trx_id，是否小于 ReadView<br>
中的min_trx_id，此时发现trx_id =32是小于 ReadView中的min_trx_id 就是45的<br>
说明你在事务开启之前，修改这行数据的事务早就提交了，所以此时你就可以看到这行数据</p>
<p>接着事务B开始动手了，他把这行数据的值改为了B，然后这行数据trx_id设置为自己的id，也就是59，<br>
同时roll_pointer指向了修改之前生成的undo log，接着这个事务B就提交了。</p>
<p>接着事务A再次查询，此时查询的时候发现一个问题，就是此时数据行里的trx_id = 59 ，那么这个trx_id是大于ReadView里的<br>
min_trx_id（45），同时又小于ReadView里的max_trx_id（60）的，说明更新这条数据的事务很有可能跟自己差不多同时开启的，<br>
于是会看一下m_ids列表中有45 和 59 两个事务id，直接证实了，这条修改数据的事务是跟自己同一时段并发执行然后提交的，所以对这行数据是不能查询的。</p>
<p>既然这行数据不能查询，那查什么？<br>
简单，顺着这条数据的roll_pointer顺着undo log日志链往下找，就会找到最近一条undo log，trx_id =32，<br>
此时发现trx_id =32 是小于ReadView里的min_trx_id =45 的 说明这个undo log版本必然是在事务A开启之前就执行且提交了。<br>
好了，那么就查询最近的那个undo log里的值好了，这就是undo log多版本链条的作用，他可以保存一个快照链条，让你可以读到之前的快照值。</p>
<p>如果事务A ，更新值A,trx_id修改为45，同时保存之前事务B修改值的快照。<br>
那么此时A来查询这条数据，会发现trx_id =45 居然和自己的ReadView里的create_trx_id = 45 的值是一样的。<br>
说明这行数据就是自己修改的，自己修改的值当然可以i看到</p>
<p>如果在事务A执行的过程中，突然开启了是一个事务C，这个事务C的id =78，然后它更新了那行的值为值C，还提交了<br>
这个时候，事务A再去查询，会发现当前数据的trx_id = 78，大于了自己的ReadView中的max_trx_id（60）此时说明了什么，<br>
说明是这个事务A开启之后，然后有一个事务更新了数据，自己当然是看不到的。<br>
此时就会顺着undo log多版本链条往下找，自然先找到值A之前修改过的那个版本，因为那个trx_id = 45 跟自己的<br>
ReadView里的create_trx_id是一样的，所以此时直接读取自己修改的那个版本</p>
<figure data-type="image" tabindex="12"><img src="image/ReadViewjizhi.png" alt="img.png" loading="lazy"></figure>
<pre><code>通过undo log多版本链条，加上你开启事务时候生产的一个ReadView，然后再有一个查询的时候，根据ReadView进
行判断的机制，你就知道你应该读取哪个版本的数据。
而且他可以保证你只能读到你事务开启前，别的提交事务更新的值，还有就是你自己事务更新的值。假如说是你事务
开启之前，就有别的事务正在运行，然后你事务开启之后 ，别的事务更新了值，你是绝对读不到的！或者是你事务开
启之后，比你晚开启的事务更新了值，你也是读不到的！
</code></pre>
<h5 id="read-committed隔离级别是如何基于readview机制实现的">Read Committed隔离级别是如何基于ReadView机制实现的？</h5>
<pre><code>每次查询都生成新的ReadView，那么如果 在你这次查询之前，有事务修改了数据还提交了，你这次查询生成的ReadView里，那个m_ids列表当然不包含这个已
经提交的事务了，既然不包含已经提交的事务了，那么当然可以读到人家修改过的值了。
这就是基于ReadView实现RC隔离级别的原理，实际上，基于undo log多版本链条以及
ReadView机制实现的多事务并发执行的RC隔离级别、RR隔离级别，就是数据库的MVCC多版本并发控制机制。
</code></pre>
<h5 id="mysql最牛的rr隔离级别是如何基于readview机制实现的">MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</h5>
<p>默认的ReadView 就是这个机制</p>
<pre><code>默认情况下，有人在更新数据的时候，你去读取这一行数据,直接默认就是开启mvcc机制的。
也就是说，此时一行数据的读和写两个操作默认是不会加锁互斥的，因为mysql的mvcc机制就是为了解决这个问题，避免频繁加锁互斥。
此时你读取数据，完全可以根据你的ReadView，去在undo log版本链条里找一个你能读取的版本，完全不用顾虑别人在不在更新。
就算你真的等他更新完毕了还提交了，基于mvcc机制，你也读取不到他更新的值啊！因为ReadView机制是不允许的，所以你默认情况下的读
，完全不需要加锁，不需要care其他食物的更新加锁问题，直接介于mvcc机制读某个快照就可以了

如果要再执行查询的时候想要加锁，mysql支持一种共享锁 就是 s锁，这种共享锁的语法
select * from table lock in mode
共享锁和独占锁互斥，独占锁之间互斥，共享锁与共享锁不互斥
    
查询的时候还能加互斥锁，也就是 X 锁（Exclude独占锁），这种独占锁的语法
select * from table for update

当有一个事务加了独占锁之后，其他事务再更新这行数据，都是要加独占锁的，但是只能生成独占锁在后面等待。

一旦你查询的时候加了独占锁，此时在你的事务提交之前，任何人都不能更新数据，只能你在本事务里更新数据，等你提交了别人在更新数据
</code></pre>
<h4 id="多个事务更新同一行数据时是如何加锁避免脏写的">多个事务更新同一行数据时，是如何加锁避免脏写的？</h4>
<p>多个事务同时更新一行数据，此时都会加锁（X 锁，也就是Exclude独占锁），然后都会等待排队，必须一个事务执行完毕了，提交了，释放了锁，才能唤醒别的事务继续执行。</p>
<p>加锁</p>
<figure data-type="image" tabindex="13"><img src="image/jiasuo.png" alt="img.png" loading="lazy"></figure>
<p>释放锁-加锁<img src="image/shifangsuojiasuo.png" alt="img.png" loading="lazy"></p>
<h5 id="共享锁">共享锁</h5>
<pre><code>如果要再执行查询的时候想要加锁，mysql支持一种共享锁 就是 s锁，这种共享锁的语法
select * from table lock in mode
共享锁和独占锁互斥，独占锁之间互斥，共享锁与共享锁不互斥


默认情况下，有人在更新数据的时候，你去读取这一行数据,直接默认就是开启mvcc机制的。
也就是说，此时一行数据的读和写两个操作默认是不会加锁互斥的，因为mysql的mvcc机制就是为了解决这个问题，避免频繁加锁互斥。

如果要再执行查询的时候想要加锁，mysql支持一种共享锁 就是 s锁，这种共享锁的语法
select * from table lock in mode
共享锁和独占锁互斥，独占锁之间互斥，共享锁与共享锁不互斥
    
查询的时候还能加互斥锁，也就是 X 锁（Exclude独占锁），这种独占锁的语法
select * from table for update

当有一个事务加了独占锁之后，其他事务再更新这行数据，都是要加独占锁的，但是只能生成独占锁在后面等待。

一旦你查询的时候加了独占锁，此时在你的事务提交之前，任何人都不能更新数据，只能你在本事务里更新数据，等你提交了别人在更新数据
</code></pre>
<h5 id="独占锁">独占锁</h5>
<pre><code>当有一个事务加了独占锁之后，其他事务再更新这行数据，都是要加独占锁的，但是只能生成独占锁在后面等待。

查询的时候还能加互斥锁，也就是 X 锁（Exclude独占锁），这种独占锁的语法

select * from table for update

一旦你查询的时候加了独占锁，此时在你的事务提交之前，任何人都不能更新数据，只能你在本事务里更新数据，等你提交了别人在更新数据
</code></pre>
<h4 id="在表级别加锁">在表级别加锁</h4>
<p>多个事务并发更新数据的时候，都要在行级别加独占锁，独占锁是互斥的，所以不可能发生脏写问题，一个事务提交了才会释放自己的独占锁，唤醒下一个事务的执行。<br>
如果你此时去读取别的事务在更新的数据，有两种可能：<br>
1.第一种可能就是基于MVCC机制进行事务隔离，读取快照版本，这个是比较常见的；<br>
2.第二种可能是查询的同时基于特殊语法去加独占锁或者共享锁。</p>
<p>一般而言，不太建议在数据卷粒度去通过行锁实现复杂的业务锁机制，而更加建议通过redis，zookeeper来用分布式锁来实现复杂业务下的锁机制</p>
<p>比较正常的情况而言，其实还是多个事务并发运行更新一行数据，默认加独占锁互斥，同时其他事物基于mvcc机制进行快照版本读实现事务隔离<br>
、表锁其实是InnoDB存储引擎的概念</p>
<h4 id="索引">索引</h4>
<h5 id="磁盘上数据页的存储结构">磁盘上数据页的存储结构</h5>
<figure data-type="image" tabindex="14"><img src="image/shujuyedecunchu.png" alt="img.png" loading="lazy"></figure>
<pre><code>大量的数据页按照顺序一页一页的存放的，然后相邻的两个数据页会采用采用双向列表的格式互相引用

然后一个数据页内部会存储一行行的数据，也就是我们平时在表里插入的一行行数据就会存储在数据页里

然后数据页里的每一行数据都会按照主键大小进行排序村粗，同时每一行数据都有一个指针指向下一行数据

的位置，组成一个单向链表。

然后每个数据页都会有一个页目录，里面根据数据行的主键存放一个目录，同时数据行是被分割存储在不同槽位里去的

如果是主键查找，在数据页的页目录里,根据主键值直接定位到槽位，遍历槽位数据行，就可以找到数据
如果是非主键查找，只能进入数据页根据单向链表查找数据
</code></pre>
<p>在没有索引的情况下查找数据</p>
<pre><code>第一个数据页遍历所有数据页查找，将数据页加载到缓存页中
如果是主键查找，在数据页的页目录里,根据主键值直接定位到槽位，遍历槽位数据行，就可以找到数据
如果非主键查找，再单向遍历查找那条数据，如果没有那条数据，再加载下一个数据页到缓存页里来
以此类推，循环往复， 其实就是一个全表扫描
</code></pre>
<h4 id="页分裂的过程">页分裂的过程</h4>
<pre><code>假如我们不停的再表里插入数据，接着数据越来越多，此时就要在搞一个数据页了
但是此时就会遇到一个问题，索引运作的一个核心基础就是要求你后一个数据页的主键值大于前面一个数据页的主键值
但是如果你的主键是自增的，还可以保证这一点，因为你新插入的后一个数据页的主键值一定都大于前一个数据页的主键值。
但是如果你的主键不是自增的，所以可能会出现你的后一个数据页的主键值里，有点小于前一个数据页的主键值。
所以此时就会出现一个过程叫做也分裂
就是万一你的主键值都是你自己设置的，那么在增加一个新的数据页的时候，实际上会把前一个数据页主键值较大，挪到新的数据页里来
然后把你新插入的主键值较小的数据挪动到上一个数据页里去。保证了新数据页里的主键值一定都比上一个数据页里的主键值大。
</code></pre>
<h4 id="主键索引">主键索引</h4>
<pre><code>我们先拿最基础的主键索引来分析，把索引原理和查询原理搞清楚

mysql针对主键设计了一个索引，针对主键的索引实际上就是主键目录这个目录呢
把每个数据页的页号，还有数据页里最小主键的值放在一起，组成一个索引目录
</code></pre>
<figure data-type="image" tabindex="15"><img src="image/zhujiansuoyin.png" alt="img.png" loading="lazy"></figure>
<pre><code>通过主键查找时，通过二分查找，对比之后，确定id到底在那个数据页，
通过页目录直接定位到数据对应的槽位，遍历槽位数据行，就可以找到数据
</code></pre>
<h4 id="b树实现索引的物理结构">B+树实现索引的物理结构</h4>
<pre><code>很多索引数据不可能一直放在索引页里，会进行分裂

在更高索引层级里，保存每个索引页里最小的主键值，如果最顶层的索引页里存放下层索引页的也好太多了怎么办？
继续分裂，加一层索引页，这就形成了B+树，
这是索引最真实的物理存储结构，采用跟数据页一样的页结构来存储，一个索引就是由很多个数据页组成的一颗B+树
</code></pre>
<h4 id="聚簇索引">聚簇索引</h4>
<p>更新数据时，自动维护的聚簇索引</p>
<pre><code>当我们要查找某个主键id 的值时，通过二分查找很容易找到对应的索引页，通过索引页就能快读定位到数据页
实际上索引页和数据页之间是有指针连接起来的
另外呢,对于同一层级的索引页互相之间都是基于指针组成双向链表的
</code></pre>
<figure data-type="image" tabindex="16"><img src="image/index1.png" alt="img.png" loading="lazy"></figure>
<pre><code>加入把索引页和数据页综合起来看,他们连接在一起,看起来就如同一颗完整的大B+树一样

在B+树里最底层的一层就是数据页,数据页也就是B+树里的叶子节点了

也就是说,上图所有的索引页+数据页组成的B+树就是**聚簇索引**

这个聚簇索引默认时按照主键来组织的,所以你在增删改的时候,一方面会更新数据页,另一方面其实会给你自动维护
B+树结构的聚簇索引,给新增和更新索引页,这个聚簇索引是默认给你建立的.
</code></pre>
<h4 id="针对主键之外的其他字段建立索引的原理">针对主键之外的其他字段建立索引的原理</h4>
<pre><code>根据主键搜索数据的原理其实很清晰了,其实就是从聚簇索引的根节点进行二分查找,一路找到对应的数据页里,
基于页目录直接定位到主键对应的数据就可以了
</code></pre>
<p>主键之外的其他字段建立索引的原理</p>
<pre><code>其实原理是一样的,简单来说,你插入数据的时候,一方面会把完整的数据插入到聚簇索引的叶子节点的数据页里面去,
同时维护好聚簇索引,另一方面会为其他字段建立索引,重新建立一颗B+树.

比如你基于name建立一个索引,那么此时你插入数据的时候,就会重新搞一个B+树(这是独立与聚簇索引的另一个索引的B+树),
B+树的叶子节点也是数据页,但是这个数据页里仅仅存放主键字段和name字段.
</code></pre>
<figure data-type="image" tabindex="17"><img src="image/qitasuoyin.png" alt="img.png" loading="lazy"></figure>
<pre><code>搜索的时候过程和主键字段一模一样,不就是从name字段的索引B+树里根节点开始一层一层往下找,一直找到
叶子节点的数据页里,定位到name字段对应的主键值.
此时还需要进行回表操作,这个回表就是根据主键值,再到聚簇索引里面从根节点开始,一路找到叶子接待你的数据页,
定位到主键对应的完整数据行.
一般吧普通字段的索引称为二级索引,一级索引就是聚簇索引
</code></pre>
<p>多个字段联合起来,建立联合索引,比如:age+name</p>
<pre><code>联合索引的运行原理也是一样的,只不过是建立了一颗独立的B+树,叶子节点里面存放了id+name+age的数据,
然后默认按照name排序,name一样就按照age排序
查询的时候和普通索引一样的原理
</code></pre>
<p>联合索引的查询原理，以及使用索引的全职匹配规则</p>
<pre><code>假如莫得sql语句的where 条件里的几个字段的名称和顺序，都是跟你的索引里的字段一样，同时你还用等号值做匹配，那就是全职匹配
通过第一个字段值，二分查找找到对应的数据页，再在数据页里面二分查找找到对应的其他值找到id之后，进行查找聚簇索引回表操作，查询出剩下的其他字段
</code></pre>
<p>这就是InnoDB存储引擎的索引的完整实现原理了.</p>
<h4 id="索引的优缺点">索引的优缺点</h4>
<p>优点：不需要全表扫描，性能提升很快<br>
缺点消耗磁盘空间，增删改的速度很比较差（因为要维护B+树结构）</p>
<h4 id="索引的使用规则">索引的使用规则</h4>
<p>设计原则：</p>
<pre><code>设计系统时，索引的设计

1.一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，才能发挥出B+树快速二分查找的优势来

2.尽量使用那些字段值比较小的列来设计索引

3.设计索引别太多，建议两三个联合索引就应该覆盖掉你这个表的全部查询了。

否则索引太多，必然导致你增删改的时候性能很差，因为要很多个索引树。

4.另外很关键一点，建议大家主键一定是自增的，别用UUID之类的
因为主键自增，那么你的聚簇索引不会频繁的分裂，主键都是有序的，就会自然新增一个列而已，如果你用得视UUID，那么会
导致聚簇索引频繁的页分裂
</code></pre>
<p>where 使用原则：</p>
<pre><code>1.联合索引的等值匹配规则
    where语句中的几个字段名称和联合索引的条件里的几个字段的名称和顺序，都是跟你的索引里的字段一样，同时你还用等号值做匹配，那就是全职匹配

2.最左侧列匹配
   这个意思是我们的联合索引是KEY(index_key1,index_key2,index_key3)
   那么不一定必须要在where语句里查询三个字段来查，其实只需要根据最左侧的部分字段来查也是可以的
   where index_key1 = '' and index_key2 = '' 是没有问题的
   但是 你要用 where index_key3 那就不行了，因为在联合索引B+树里，是必须先按index_key1，再按index_key2，
   不能跳过前面两个字段直接按照最后一个index_key3 来查
   另外 where index_key1 = '' and index_key3 = '' ,那么饿只要index_key1在索引里能搜到，剩下的index_key3
    没办法在索引中找到
   所以，在建立所以的过程中，你必须建立好联合索引的字段，以及平时你写sql的时候要按照哪几个字段来查

3.最左前缀匹配规则
  即如果你要用like语法来查  like '1%'，是可以用到索引的  ，但是 like '%1'，没法用索引

4.范围查找规则
    同最左侧匹配

5.等值匹配+范围匹配规则
 同最左侧匹配
</code></pre>
<p>order 在sql进行排序，如何使用索引</p>
<pre><code>通常情况下，我们建立INDEX(xxx1,xxx2,xxx3)这样的联合索引，
这个时候默认情况下索引树里本身就是依次按照xxx1,xxx2,xxx3三个字段的值进行排序的
这个时候 用order by xxx1 ,xxx2,xxx3，在联合索引的索引树里都排好了，直接取出数据，
再去聚簇索引里面回表查询所有字段
但是这里有一个限定规则，因为联合索引里的字段值在索引树里都是从小到大一次排序的，
所以order by 要么都降序，要么都升序
不能有的字段降序，有的字段升序，那是不能用索引的
</code></pre>
<p>group by 在在sql中进行分组，如何使用索引<br>
通常而言 group by 后的字段，最好也是按照联合索引最左侧的字段开始，按顺序排列开来，这样的话就可以完美的<br>
运用上索引直接提取一组一组数据，然后对每组数据进行聚合就可以了。</p>
<p>覆盖索引</p>
<pre><code>覆盖索引是不是一种索引，他就是一种基于索引的查询方式罢了。
仅仅需要联合索引里面的几个字段的值，那么其实只要扫描联合索引的索引树就可以了
这种查询的方式就是覆盖索引，这样就不需要回表
</code></pre>
<p>最好使用覆盖索引<br>
即使真的要回表到聚簇索引，那你尽可能的用limit 和where 之类的语句<br>
限定一下回表到聚簇索引的次数，这样性能也要好一些</p>
<h4 id="索引的设计规则">索引的设计规则</h4>
<p>1.一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，才能发挥出B+树快速二分查找的优势来</p>
<p>2.尽量使用那些字段值比较小的列来设计索引</p>
<p>3.设计索引别太多，建议两三个联合索引就应该覆盖掉你这个表的全部查询了。</p>
<p>否则索引太多，必然导致你增删改的时候性能很差，因为要很多个索引树。</p>
<p>4.另外很关键一点，建议大家主键一定是自增的，别用UUID之类的<br>
因为主键自增，那么你的聚簇索引不会频繁的分裂，主键都是有序的，就会自然新增一个列而已，如果你用得视UUID，那么会<br>
导致聚簇索引频繁的页分裂</p>
<h4 id="执行计划">执行计划</h4>
<p>每一次提交sql给mysql，他内核的查询优化器，都会针对这个sql语句的语义去生成一个执行计划，<br>
这个执行计划就代表了，如何筛选过滤如何使用函数，如何进行排序，如何进行分组。</p>
<p>执行计划里包含哪些内容：<br>
1.数据的访问方式：</p>
<p>const - ref -range - index -- all</p>
<pre><code>const:肯定是通过了主键或者唯一索引，速度超高
ref:普通索引  或者主键唯一索引 搞了is null 或者 is not null
range:利用索引来进行范围筛选，一旦索引做了范围筛选，那么这种方式就是range
index:只要遍历组合索引就可以，不需要回表到聚簇索引中去，针对这种只需要遍历二级索引就能拿到你想要的数据，而不需要回源到聚簇索引的访问方式
all:直接全表扫描
</code></pre>
<p>const ，ref ，range :本质上都是居于索引树的二分查找和多层跳转来查询的，所以性能都是很高的<br>
接着接下来就是index 速度上比上面三种压迫差一些，因为他是走遍历二级索引树的叶子节点的方式来执行的<br>
那肯定比基于索引树的二分查找要慢多了，但是还是比全表扫描好一些。</p>
<p>多表关联的sql是如何执行的？</p>
<p>select * from tabel1 t1, table2 t2 where t1.xx = xxx,t2.xxx= xxx and t1.xxx2 = t2.xxx2</p>
<p>sql关联语法的实现原理（嵌套循环关联）：</p>
<pre><code>1.首先根据t1.xxx 表里查询出来一批数据，此时可能是const， ref ,index 或者all，具体看你的索引怎么建立的，他会挑一种执行计划的访问方式。
2.筛选出t1表的数据后，比如说找到两条数据，根据每条数据xxx2的值，以及t2.xxx2这个条件去t2表里找x2字段值和xxx 都匹配的字段值
这时就把两个表的数据关联起来了，另一条数据也是如法炮制。
</code></pre>
<p>记住，他可能是先从表里查一波数据，这个表叫做”驱动表“，再根据这波数据去另一个表查一波数据进行关联，另一个表叫做”被驱动表“</p>
<p>内连接：inner join 意思是两个表的数据必须完全关联上，才能返回回来<br>
外连接：outer join 可分为左外连接（左连接），右外连接（有连接）<br>
如果你是之前的那种内连接，那么连接条件可以放在where语句里，但是外连接一般是把连接条件放在ON字句里的</p>
<p>其实一般写多表关联，主要就是内连接和外连接，连接的语义和实现过程</p>
<p>mysql是如何根据成本优化执行计划的？</p>
<p>全表扫描的成本计算：</p>
<pre><code>show like status like '表名';
rows:表里的记录数
data_length:代表表的聚簇索引的字节数大小 默认是byte

全表扫描的 IO成本：数据页的数量* 1.0 +微调值
         CPU成本：行记录数 * 0.2 + 微调值
总成本= IO成本+CPU成本
</code></pre>
<p>索引的成本计算：</p>
<p>1.基于IN查询的子查询方式的优化：</p>
<p>sql物化表：存储引擎通过内存来存放，如果结果集太大，则可能采用普通B+树聚簇索引的方式存放在磁盘里<br>
但是无论如何，这个物化表都会建立索引。</p>
<p>2.对子查询的另一种优化方式：半连接</p>
<p>在互联网公司，比较崇尚的是尽量写简单的sql，复杂的逻辑用java系统来实现就可以了<br>
sql能单表就不要多表关联，能多表关联就尽量别写子查询，多考虑用java代码在内存里实现<br>
一些数据的复杂计算逻辑，而不是都放在sql里做。</p>
<p>执行计划落实到底层无非就是先访问哪张表，用哪个索引还是全表扫描，拿到数据之后如何去聚簇索引中回表<br>
是否要基于临时磁盘文件做分组聚合或者排序</p>
<p>查看执行计划的内容</p>
<p>id：每个select 都会对应一个id<br>
select_type:说的就是这一条执行计划对应查询的是个什么查询类型<br>
table：就是表名，意思是要查询哪张表<br>
partitions:是表分区的概念<br>
type:当前这个表的访问方式，比如说 const ref range index all<br>
possible_keys:可能选择的索引<br>
key：实际上选择的索引<br>
key_len:就是索引的长度<br>
ref:就是使用某个字段的索引进行等值匹配搜索的时候，跟索引列等值匹配的那个目表值得一些信息<br>
rows:是预估通过索引或者别的方式访问这个表的时候，大概可能取多少条数据，<br>
filtered:就是通过搜索条件过滤后得剩下数据得百分比<br>
extra：一些额外得信息</p>
<p>select_type:</p>
<pre><code>一般单表或者多表连接查询，他们得select_type都是SIMPLE，就是简单得查询
如果是union 语句，第一条执行计划针对表1，select_type 就是 PRIMARY
                第二条执行计划针对表2，select_type 就是 UNION
                第三条执行计划就是针对两个查询结果依托 一个临时表去重
                第三条执行计划 select_type 就是 union_result
如果是子查询，第一条执行计划 select_type 就是 PRIMARY
            第二条执行计划 select_type 就是SUBQUERY  
            select_type 是DERIVED 针对子查询得结果集会物化一个内部临时表
</code></pre>
<h4 id="sql调优">Sql调优</h4>
<pre><code>在sql调优的时候，核心就是分析执行计划里哪些出现了全表扫描，或者扫描的数据过大，尽可能的通过合理
优化索引保证执行计划每个步骤都是基于索引执行，避免扫描过多的数据
</code></pre>
<p>如果mysql使用了错误得执行计划应该怎么办？<br>
使用 force index 语法就可以了</p>
<p>select * from table fore index (index) where  index = &quot;&quot;</p>
<p>为什么mysql 默认会选对主键得聚簇索引进行扫描？</p>
<h3 id="mysql物理存储">mysql物理存储</h3>
<h4 id="varchar这种变长字段在磁盘上到底是如何存储的">VARCHAR这种变长字段，在磁盘上到底是如何存储的</h4>
<p><strong>引⼊变长字段的长度列表，解决⼀⾏数据的读取问题：</strong></p>
<pre><code>将数据的长度转成16进制表示，放在数据存储的前面
</code></pre>
<p><strong>多个变长字段是如何存储的？</strong></p>
<pre><code>此时在磁盘中存储的，必须在他开头的变长字段长度列表中存储⼏个变长字段的长度，⼀定要注意⼀点，他这⾥是逆
序存储的！
</code></pre>
<p>0x05 null值列表 数据头 hello a a 0x02 null值列表 数据头 hi a a</p>
<p><strong>mysql的一行行数据紧凑存储有什么好处？</strong></p>
<pre><code>多行紧凑的原因有： 序列化反序列时的开销小；不易有内存碎片；定位数据时比较快速
</code></pre>
<h4 id="一行数据中的多个null字段值在磁盘上怎么存储">一行数据中的多个NULL字段值在磁盘上怎么存储</h4>
<p><strong>为什么一行数据的NULL值不能直接存储？</strong></p>
<pre><code>肯定不是按照字符串的方式存储，会浪费空间。
</code></pre>
<p><strong>NULL值是以二进制Bit来存储的？</strong></p>
<pre><code>bit值是1 说明是NULL，如果是0 说明不是NULL
</code></pre>
<p><strong>磁盘上的⼀⾏数据到底如何读取出来的？</strong></p>
<pre><code>我们结合上⾯的磁盘上的数据存储格式来思考⼀下，⼀⾏数据到底是如何读取出来的呢？
再看上⾯的磁盘数据存储格式：
0x09 0x04 00000101 头信息 column1=value1 column2=value2 ... columnN=valueN

⾸先他必然要把变长字段长度列表和NULL值列表读取出来，通过综合分析⼀下，就知道有⼏个变长字段，哪⼏个变长
字段是NULL，因为NULL值列表⾥谁是NULL谁不是NULL都⼀清⼆楚。
此时就可以从变长字段长度列表中解析出来不为NULL的变长字段的值长度，然后也知道哪⼏个字段是NULL的，此时
根据这些信息，就可以从实际的列值存储区域⾥，把你每个字段的值读取出来了。
如果是变长字段的值，就按照他的值长度来读取，如果是NULL，就知道他是个NULL，没有值存储，如果是定长字
段，就按照定长长度来读取，这样就可以完美的把你⼀⾏数据的值都读取出来了！
</code></pre>
<h4 id="磁盘文件中40个bit位的数据头以及真实数据是如何存储的">磁盘文件中40个bit位的数据头以及真实数据是如何存储的</h4>
<pre><code>每一行数据在磁盘上存储的时候，每一行数据都会有变长字段长度列表，逆序存放这行数据里的变长字段的长度，  
然后会有NULL值列表，对于允许NULL值得字段都会有一个bit位标识那个字段是否为NULL，也是逆序排序得
</code></pre>
<p>每一行数据存储得时候，还得有一个bit位得数据头，这个数据头是用来描述这行数据的。</p>
<pre><code>第一位bit和第二位bit都是预留位，是没有任何含义的。
接下来的bit位是delete_mask：他标识这行数据是否被删除了
下一个bit位是min_rec_mask：在B+树里每一层的非页字节点里最小值都有这个标记
接下来是4个bit位是n_owned：记录了一个记录数
接下来13个bit位是heap_no，他代表是当前这行数据在数据堆里的位置
然后是3个bit位record_type：也就是这行数据的类型
   0:代表普通类型
   1：代表是B+树非叶子节点
   2：代表是最小值的数据 
   3：代表最大值的数据
最后16位bit是next_record:这个是他下一条数据的指针
</code></pre>
<h4 id="一行数据实际在磁盘上的存储">一行数据实际在磁盘上的存储</h4>
<p><img src="image/mysqlcipancunchu.png" alt="img.png" loading="lazy">变长字段列表 NULL值列表 数据头 真实数据</p>
<p>在实际存储一行数据的时候，会在他真实数据部分，添加一些隐藏字段</p>
<pre><code>DB_ROW_ID 字段：这是一个行的唯一标识，是数据库内部的一个标识，不是你的主键ID字段，入股我们没有指定主键和
unique key 唯一索引的时候，他的内部就会自动加一个DB_ROW_ID

DB_TRX_ID字段，这个跟事务相关，他是说这是哪个事务更新的数据，这是事务ID。

DB_ROLL_PTR，这是回滚指针，用来进行事务回滚的
</code></pre>
<h4 id="行溢出">行溢出</h4>
<p>行溢出：就是一行的数据存储太多的内容，一个数据页都放不下，此时只能溢出这个数据页，把数据溢出存放到其他数据页里去，那些数据页就叫做溢出页。</p>
<h4 id="表空间">表空间</h4>
<pre><code>表空间：我们平时创建的那些表，其实就是都有一个表空间的概念，在磁盘上对会对应'表明.ibd'，这样的一个磁盘数据文件。’

‘一个表空间磁盘文件里，其实会有很多很多的数据页，为了便于管理，表空间又引入了**数据区（extent）**
一个数据区对应64个连续的数据页，每个数据页的大小是16kb，所以一个数据区就是1mb，然后256个数据区被划分为一组。

当我们需要执行CRUD操作的时候，说白，就是从磁盘上表空间的数据文件里，去加载一些数据页出来到buffer pool的缓存页里区使用
</code></pre>
<figure data-type="image" tabindex="18"><img src="image/shujuqu.png" alt="img.png" loading="lazy"></figure>
<h3 id="生产实践">生产实践</h3>
<h4 id="真实生产环境下的数据库机器配置如何规划">真实生产环境下的数据库机器配置如何规划</h4>
<p>普通应用的机器选择？</p>
<pre><code>就经验而言，普通的系统 4核8G ，每秒抗几百的请求没问题，
数据库通常是在8核16G以上正常的是16核32G
</code></pre>
<p>高并发场景数据库应该选择什么样的机器？</p>
<pre><code>磁盘，io，网络压力会比较大，最好采用ssd固态硬盘
</code></pre>
<h4 id="互联网公司的生产环境数据库是如何进行性能测试的">互联网公司的生产环境数据库是如何进行性能测试的？</h4>
<p>请求测试指标：QPS、TPS</p>
<pre><code>QPS：Query Per Second，每秒可以处理多少个请求，也就是说这个数据库每秒可以处理多少个sql

TPS：Transaction Per Second 。其实就是每秒可处理的事物
</code></pre>
<p>IO相关压测性指标</p>
<pre><code>IOPS：这个是机器随机IO并发处理能力
这个指标很关键，你在内存中更新的脏数据，最后都会由后台IO在不确定时间，刷回到磁盘里去。这个是随机IO的过程，
如果说IOPS指标太低了，那么会导致脏数据刷回磁盘的效率不高。


吞吐量：这个指机器的磁盘存储每秒可以读写多少个字节的数据
这个指标也很关键，因为大家通过学习都知道，我们在平时执行各种sql的时候，提交事物的时候，其实都会有大量会写redo log日志之类的，这些日志都会直接写磁盘

latency：这个指标说的往磁盘里写入一条数据的延迟。
这个指标同样很重要，因为我们执行sql语句和提交事物的时候，都需要顺序写redo log 次哦盘文件，所以此时
你写一条日志到磁盘文件里去，到底延迟是1ms还是100us，这就是对你的数据库sql语句执行性能是有影响的
</code></pre>
<p>其它指标</p>
<pre><code>CPU负载：PU负载是⼀个很重要的性能指标，因为假设你数据库压测到了每秒处理3000请求了，可能其他的性能指标
都还正常，但是此时CPU负载特别⾼，那么也说明你的数据库不能继续往下压测更⾼的QPS了，否则CPU是吃不消的。

网络负载：这个主要是要看看你的机器带宽情况下，在压测到⼀定的QPS和TPS的时候，每秒钟机器的⽹卡会输⼊多少
MB数据，会输出多少MB数据，因为有可能你的⽹络带宽最多每秒传输100MB的数据，那么可能你的QPS到1000的时候，⽹
卡就打满了，已经每秒传输100MB的数据了，此时即使其他指标都还算正常，但是你也不能继续压测下去了

内存负载：：这个就是看看在压测到⼀定情况下的时候，你的机器内存耗费了多少，如果说机器内存耗费过⾼了，说明也
不能继续压测下去了
</code></pre>
<h4 id="如何对生产环境中的数据库进行360度无死角压测httpsapppukyptrl1086pcxiaoe-techcomdetaili_5e383c5357307_mjhluwmb1fromp_5e0c2a35dbbc9_mndgdybatype6">如何对生产环境中的数据库进行360度无死角压测？（https://apppukyptrl1086.pc.xiaoe-tech.com/detail/i_5e383c5357307_MjhluwMb/1?from=p_5e0c2a35dbbc9_MNDGDYba&amp;type=6）</h4>
<p>在linux 安装sysbench</p>
<pre><code>curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh | sudo bash
sudo yum -y install sysbench
sysbench --version
如果上⾯可以看到sysbench的版本号，就说明安装成功了

QPS：Query Per Second，每秒可以处理多少个请求，也就是说这个数据库每秒可以处理多少个sql

TPS：Transaction Per Second 。其实就是每秒可处理的事物
</code></pre>
<p>如何为生产环境中的数据库部署监控系统</p>
<pre><code>Prometheus：其实就是一个监控数据采集和存储系统，它可以利用采用缉拿空数据采集组件从你指定的Mysql数据库中采集他需要的监控数据
然后他自己由一个时序数据库，他会把采集道德监控数据放到自己的时序数据库中，本质就是存储在磁盘文件里。

Grafana：就是一个可视化的监控数据展示系统，他可以Prometheus采集到的大量mysql监控数据展示成各种精美报告，可以让我们直接看到mysql的监控情况。
</code></pre>
<h4 id="如何通过多个buffer-pool来优化数据库的并发性能">如何通过多个Buffer Pool来优化数据库的并发性能</h4>
<p>多线程并发访问一个Buffer Pool的时候必然会加锁，然后很多线程可能要串行着排队，一个个的依次执行操作。</p>
<p>一般来说，Mysql默认的规则是，如果你给Buffer Pool分配的内存大小小于1GB，那么最多就会给你一个Buffer Pool</p>
<p>但是如果你的机器内存就很大，那么此时你是可以同时设置多个Buffer Pool</p>
<pre><code>  innodb_buffer_pool_size = 8589934592
  innodb_buffer_pool_instance = 4
</code></pre>
<p>我们给Buffer Pool 设置了8GB的总内存，然后设置了4个Buffer Pool，也就是说每个Buffer Pool的大小是2GB</p>
<p>所以在生产实践中设置多个Buffer Pool 来优化高并发访问的性能，是mysql一个很重要的优化技巧。</p>
<h4 id="如何通过chunk来支持数据库运行期间的buffer-pool动态调整">如何通过chunk来支持数据库运行期间的Buffer Pool动态调整</h4>
<p>实际上Buffer Pool是由很多个chuck组成的，他的大小是innodb_buffer_pool_chunk_size 来控制的默认值是128M</p>
<pre><code>所以实际上我们可以做一个假设，比如现在我们给Buffer Pool 设置一个总大小是8GB，然后4个Buffer Pool ，那么每个Buffer Pool 就是2GB
 此时每个Buffer Pool 是由一系列的128M chuck组成的，也就是说每个Buffer Pool 会有16个chuck，然后每个Buffer Pool里的每个chuck里就是一系列
数据描述和缓存页，每个Buffer Pool里的多个chuck共享一套 free flush lru 链表 
</code></pre>
<h4 id="在生产环境中如何基于机器配置来合理设置buffer-pool">在生产环境中，如何基于机器配置来合理设置Buffer Pool</h4>
<p>Buffer Pool 的大小一般设置为机器大小的50-60%</p>
<p>确定了Buffer pool 的总大小之后，就得考虑设置多少个buffer pool以及chuck</p>
<p>一般来说： buffer pool总大小 = （chuck大小 * buffer pool数量）的倍数</p>
<h4 id="linux操作系统的存储系统软件层原理剖析以及io调度优化原理">Linux操作系统的存储系统软件层原理剖析以及IO调度优化原理</h4>
<p>Linux的存储系统分为VFS层、⽂件系统层、Page Cache缓存层、通⽤Block层、IO调度层、Block设备驱动 层、Block设备层，</p>
<figure data-type="image" tabindex="19"><img src="image/linuxcunchujiegou.png" alt="img.png" loading="lazy"></figure>
<p>当mysql发起随机读写或者一次顺序写redo log日志文件的顺序读写的时候，实际上会把磁盘IO请求交给linux操作系统的VFS层</p>
<p>VFS层：根据你是对哪个目录中的文件执执行磁盘IO操作，把IO请求交给具体的文件系统。</p>
<pre><code>举个例⼦，在linux中，有的⽬录⽐如/xx1/xx2⾥的⽂件其实是由NFS⽂件系统管理的，有的⽬录⽐如/xx3/xx4⾥的⽂件
其实是由Ext3⽂件系统管理的，那么这个时候VFS层需要根据你是对哪个⽬录下的⽂件发起的读写IO请求，把请求转
交给对应的⽂件系统，如下图所⽰

接着⽂件系统会先在Page Cache这个基于内存的缓存⾥找你要的数据在不在⾥⾯，如果有就基于内存缓存来执⾏读
写，如果没有就继续往下⼀层⾛，此时这个请求会交给通⽤Block层，在这⼀层会把你对⽂件的IO请求转换为Block IO
请求，如下图所⽰

接着IO请求转换为Block IO请求之后，会把这个Block IO请求交给IO调度层，在这⼀层⾥默认是⽤CFQ公平调度算法的
也就是说，可能假设此时你数据库发起了多个SQL语句同时在执⾏IO操作。
有⼀个SQL语句可能⾮常简单，⽐如update xxx set xx1=xx2 where id=1，他其实可能就只要更新磁盘上的⼀个block
⾥的数据就可以了
但是有的SQL语句，⽐如说select * from xx where xx1 like &quot;%xx%&quot;可能需要IO读取磁盘上的⼤量数据。
那么此时如果基于公平调度算法，就会导致他先执⾏第⼆个SQL语句的读取⼤量数据的IO操作，耗时很久，然后第⼀
个仅仅更新少量数据的SQL语句的IO操作，就⼀直在等待他，得不到执⾏的机会。
所以在这⾥，其实⼀般建议MySQL的⽣产环境，需要调整为deadline IO调度算法，他的核⼼思想就是，任何⼀个IO操
作都不能⼀直不停的等待，在指定时间范围内，都必须让他去执⾏。
所以基于deadline算法，上⾯第⼀个SQL语句的更新少量数据的IO操作可能在等待⼀会⼉之后，就会得到执⾏的机会，
这也是⼀个⽣产环境的IO调度优化经验。
我们看下图，此时IO请求被转交给了IO调度层


最后IO完成调度之后，就会决定哪个IO请求先执⾏，哪个IO请求后执⾏，此时可以执⾏的IO请求就会交给Block设备驱
动层，然后最后经过驱动把IO请求发送给真正的存储硬件，也就是Block设备层，如下图所⽰。

然后硬件设备完成了IO读写操作之后，要不然是写，要不然是读，最后就把响应经过上⾯的层级反向依次返回，最终
MySQL可以得到本次IO读写操作的结果
</code></pre>
<figure data-type="image" tabindex="20"><img src="image/RAIDchongfangdian.png" alt="img.png" loading="lazy"></figure>
<h4 id="数据库服务器使用的raid存储架构初步介绍">数据库服务器使用的RAID存储架构初步介绍</h4>
<pre><code>所以MySQL数据库软件都是安装在一台linux服务器上的，然后启动MySQL的进程，就是启动了一个MySQL数据库

MySQL运行过程中，他需要使用CPU、内存、磁盘和网卡这些硬件，但是不能直接使用，都是通过调用操作系统提供的接口，依托于操作系统来使用和运行的，然后linux操作系统负责操作底层的硬件。
</code></pre>
<figure data-type="image" tabindex="21"><img src="image/mysql_1.png" alt="img.png" loading="lazy"></figure>
<pre><code>数据库部署在机器上的时候，存储都是搭建的RAID存储架构

RAID就是一个磁盘冗余阵列

RAID这个技术，大致理解为用来管理机器里的多块磁盘的一种磁盘阵列技术！

有了他以后，你在往磁盘里读写数据的时候，他会告诉你应该在哪块磁盘上读写数据，
</code></pre>
<figure data-type="image" tabindex="22"><img src="image/img_1.png" alt="img_1.png" loading="lazy"></figure>
<pre><code>有了RAID这种多磁盘阵列技术之后，我们是不是就可以在一台服务器里加多块磁盘，扩大我们的磁盘存储空间了？

当我们往磁盘里写数据的时候，通过RAID技术可以帮助我们选择一块磁盘写入，在读取数据的时候，我们也知道从哪块磁盘去读取。
</code></pre>
<p>除此之外，RAID技术很重要的一个作用，就是他还可以<strong>实现数据冗余机制</strong></p>
<pre><code>所谓的数据冗余机制，就是如果你现在写入了一批数据在RAID中的一块磁盘上，然后这块磁盘现在坏了，无法读取了，那么岂不是你就丢失了一波数据？如下图所示

![img.png](image/mysql_3.png)
</code></pre>
<p>所以其实有的RAID磁盘冗余阵列技术里，是可以把你写入的同样一份数据，在两块磁盘上都写入的.<br>
这样可以让两块磁盘上的数据一样，作为冗余备份，然后当你一块磁盘坏掉的时候，可以从另外一块磁盘读取冗余数据出来，这一切都是RAID技术自动帮你管理的，不需要你操心， 如下图。</p>
<figure data-type="image" tabindex="23"><img src="image/mysql_4.png" alt="img.png" loading="lazy"></figure>
<p>所以RAID技术实际上就是管理多块磁盘的一种磁盘阵列技术，他有软件层面的东西，也有硬件层买的东西，比如有RAID卡这种硬件设备。</p>
<p>具体来说，RAID还可以分成不同的技术方案，比如RAID 0、RAID 1、RAID 0+1、RAID2，等等，一直到RAID 10，很多种不同的多磁盘管理技术方案</p>
<h4 id="数据库服务器上的raid存储架构的电池充放电原理">数据库服务器上的RAID存储架构的电池充放电原理</h4>
<p>RAID緩存模式設置為write back，意思是先寫緩存再寫磁盤整列<br>
<img src="image/RAIDchongfangdian.png" alt="img.png" loading="lazy"></p>
<p>鋰電池會性能减弱，所以需要对锂电池的配置订定时充放电。</p>
<p>充电的过程中 RAID缓存级别会从write back 变成write through，这个时候IO直接些磁盘。性能会下降，导致数据库抖动出现性能抖动。</p>
<h4 id="raid锂电池充放电导致的mysql数据库性能抖动的优化">RAID锂电池充放电导致的MySQL数据库性能抖动的优化</h4>
<p>RAID 0：同时些很多快磁盘，读写并发能力强，容易丢失数据 RAID 1：两块磁盘为镜像关系，所写的数据在另一块磁盘上都有，形成数据冗余，防止数据丢失，分摊读写的压力。</p>
<p>RAID 10 = RAID 0 + RAID 1：写的时候使用RAID 0 的思路，备份使用RAID 1 的思路。</p>
<p>对于RAID 锂电池充放电问题导致的存储性能抖动，一般有三种解决方案：</p>
<pre><code>1.给RAID卡把锂电池换成电容，电容是不用频繁充放电的，不会导致充放电的性能抖动，还有就是电容可以支持透明充放电，就是自动检查电量，自动进行充电，不会说在充放电的时候让写IO直接走磁盘，但是更换电容很麻烦，而且电容比较容易老化，这个其实一般不常用

2.手动充放电，这个比较常用，包括一些大家知道的顶尖互联网大厂的数据库服务器的RAID就是用了这个方案避免性能抖动，就是关闭RAID自动充放电，然后写一个脚本，脚本每隔一段时间自动在晚上凌晨的业务低峰时期，脚本手动触发充放电，这样可以避免业务高峰期的时候RAID自动充放电引起性能抖动

3.充放电的时候不要关闭write back，就是设置一下，锂电池充放电的时候不要把缓存级别从write back修改为write through，这个也是可以做到的，可以和第二个策略配合起来使用
</code></pre>
<h4 id="数据库无法连接故障的定位toomanyconnections">数据库无法连接故障的定位TooManyConnections</h4>
<p>TooManyConnections 说明数据库连接池已经满了，你的业务系统不能与他建立更多的连接了。</p>
<p>检查mysql的配置文件 my.conf，里面有个关键的参数max_connections就是mysql建立的最大连接数。</p>
<p>查看mysql实际最大连接数</p>
<pre><code>show variables like 'max_connections'
</code></pre>
<p>mysql无法设置max_connections期望值，只能强行限制为214？为什么？</p>
<pre><code>    简单来说，就是因为底层linux操作系统把进程可以打开的文件句柄数限制为1024了导致mysql最大连接数时214
    为什么linux的最大文件句柄限制为1024的时候，MySQL的最大连接数是214呢？ 
    原因其实是mysql内部源码写死的，它在源码中就是有一个公式，算下来如此罢了
</code></pre>
<p>如何解决经典的Too Many Connections故障，背后的原理是什么？</p>
<pre><code>    ulimit -HSn 65535
    然后就可以用如下命令检查最大文件句柄数是否被修改了
    cat /etc/security/limits.conf
    cat /etc/rc.local
    如果都修改好了之后，可以在mysql的my.cnf里确保max_connections参数也调整好了，然后就可以重启服务器，重启mysql，
    这样的话，linux的最大文件句柄就会生效了，mysql最大连接数也会生效了
</code></pre>
<h4 id="线上数据库不确定性的性能抖动优化">线上数据库不确定性的性能抖动优化</h4>
<p>sql语句性能会出现不正常的莫名其妙的抖动，平时可能即使毫秒，现在居然要几秒钟，根本原因有两种：</p>
<p>1.第一个可能buffer pool缓存页都满了，此时你的sql查询了很多数据，一下把很多缓存页flush到磁盘上去，刷磁盘太慢了，就会导致你的查询语句执行的很慢。</p>
<p>2.第二种可能是你执行更新语句的时候，redo log在磁盘上的所有文件都写满了，此时需要回到第一个redo log文件覆盖写，覆盖写可能就涉及到第一个redo log文件里有很多<br>
redo log日志对应的更新操作改动了缓存页，那写缓存页还没有flush到磁盘，此时就必须把哪些缓存页的flush到磁盘，才能执行后续的更新语句，那么这一等待<br>
必然会导致更新执行很慢</p>
<p>如何尽可能的优化Mysql的一些参数，减少这种缓存页flush到磁盘带来的性能抖动的问题？</p>
<pre><code>1.对于不是数据库的机器一定要采用ssd的磁盘，
2.innodb_io_capacity 这个参数是告诉数据库采用多大的io速率把缓存页flush到磁盘里去的
    可以使用fio工具测试磁盘最大随机io速率之后，就知道他每秒可以执行多少次随机io
3.innodb_flush_neighbors,意思是在flush缓存页到磁盘德时候，可能会把缓存页临近的其他缓存页也刷到磁盘
但是这样有时候会导致flush缓存也太多了，实际上如果你使用的是SSD固态硬盘，并没必要让他同时刷进临近的缓存页，
可以把innodb_flush_neighbors设置为0，禁止刷进缓存页
</code></pre>
<h2 id="mysql主从架构">mysql主从架构</h2>
<h3 id="主从架构的原理">主从架构的原理</h3>
<p>大致来说：就是主库接受增删改的操作，把增删改操作binlog写入本地文件，然后从库发送请求来拉取binlog,接着从库上重复执行一遍binlog的操作，就可以还原出一样的数据。</p>
<h3 id="主从复制架构的搭建最基础架构">主从复制架构的搭建(最基础架构)</h3>
<p>事前准备：</p>
<pre><code>1.首先确保主库和从库的server_id是不同的，这个是必然的
2.主库必须打开binlog功能，你必须打开binlog功能，主库才会写binlog到本地磁盘，接着按照如下步骤
</code></pre>
<p>1.在主库上创建一个主从复制的账号</p>
<pre><code>create user 'backup_user'@'192.168.31.%' identified by 'backup_123';
grant replication slave on *.* to 'backup_user'@'192.168.31.%';
flush privileges;
</code></pre>
<p>2.如果主库跑了一段时间，现在要挂一个从库，应该在凌晨时，对主库和从库做一个数据备份和导入</p>
<pre><code>可以使用mysqldump工具把主库在这个时刻的数据全量备份，但是此时一定是不允许操作主库的，主库的数据时不能有变动的
/usr/local/mysql/bin/mysqldump --single-transaction -uroot -proot --master-data=2 -A &gt; backup.sql

注意，mysqldump工具就是在你的Mysql安装目录的bin目录下，然后用上述命令对你的主库所有的数据都做一个备份，
备份会以sql语句的方式进入指定的backup.sql 文件，只要执行backup.sql 就可以恢复出来跟主库一样的数据了

--master-data=2，是说备份的sql文件里，要记录一下此时主库的binlog文件和position号这是为了主从复制做准备的

接着从库执行下面的命令取执行主库进行复制

CHANGE MASTER TO MASTER_HOST='192.168.31.229',
MASTER_USER='backup_user',MASTER_PASSWORD='backup_123',MASTER_LOG_FILE='mysqlbin.000015',MASTER_LOG_POS=1689;

可能有人会疑惑，上面的master机器的ip地址我们是知道的，master上用于执行复制的用户名和密码是我们自己创建
的，也没问题，但是master的binlog文件和position是怎么知道的？这不就是之前我们mysqldump导出的
backup.sql里就有，大家在执行上述命令前，打开那个backup.sql就可以看到如下内容：
MASTER_LOG_FILE='mysql-bin.000015',MASTER_LOG_POS=1689
然后你就把上述内容写入到主从复制的命令里去了。
接着执行一个开始进行主从复制的命令：start slave，再用show slave status查看一下主从复制的状态，主要看到
Slave_IO_Running和Slave_SQL_Running都是Yes就说明一切正常了，主从开始复制了。
接着就可以在主库插入一条数据，然后在从库查询这条数据，只要能够在从库查到这条数据，就说明主从复制已经成
功了。
这仅仅是最简单的一种主从复制，就是异步复制，就是之前讲过的那种原理，从库是异步拉取binlog来同步的，所以
肯定会出现短暂的主从不一致的问题的，比如你在主库刚插入数据，结果在从库立马查询，可能是查不到的。
</code></pre>
<p>只要你搭建出来主从复制架构，就可以实现读写分离了<br>
可以用mycat 或者sharding-sphere之类的中间件，就可以实现你的系统写入主库，从库去读取</p>
<p>主从架构默认是异步的复制方式，意思是说主库把日志写入到binlog文件，接着自己提交事务返回了，他不管从库是否受到日志</p>
<p>如果主库宕机，从库切换为主库，可能发生数据丢失。</p>
<h5 id="主从半复制生产实践">主从半复制（生产实践）</h5>
<p>因此一般来说，搭建主从复制都是采用半同步的方式复制的，这个半同步的意思是，你主库写入数据，日志进入binlog之后，起码确保binlog<br>
日志复制到从库，才提交事务。</p>
<p>这个半同步复制的方式有两种</p>
<pre><code>    1.第一种叫做AFTER_COMMIT方式，他不是默认的，他的意思是说，主库写入日志到binlog，等待binlog日志复制到从库
    主库就提交自己的本地事务，接着就等待从库返回给自己一个成功的响应，然后主库就返回提交事务成功的响应给客户端。
</code></pre>
<p>（传统的搭建方式）<br>
搭建半复制也很简单，在搭建好异步复制的基础上，安装好版复制的插件就可以了，先在主库上安装半复制插件同时还得开启半复制功能</p>
<pre><code>install plugin rpl_semi_sync_master soname 'semisync_master.so';
set global rpl_semi_sync_master_enabled=on;
show plugins;
</code></pre>
<p>可以看到你安装了这个插件那就ok了</p>
<p>接着从库上页安装这个插件以及开启半复制功能：</p>
<pre><code>install plugin rpl_semi_sync_master soname 'semisync_master.so';
set global rpl_semi_sync_master_enabled=on;
show plugins;
</code></pre>
<p>接着要重启从库的IO线程：stop slave io_thread; start slave io_thread;</p>
<p>然后在主库上检查一下半同步复制是否正常运行：show global status like '%semi%';，如果看到了<br>
Rpl_semi_sync_master_status的状态是ON，那么就可以了。</p>
<p>到此半同步复制就开启成功了，其实一般来说主从复制都建议做成半同步复制，因为这样配合高可用切换机制，就可以保证数<br>
据库有一个在线的从库热备份主库的数据了，而且主要主库宕机，从库立马切换为主库，数据不丢失，数据库还高可用。</p>
<p>（GTID）搭建方式</p>
<p>首先在主库进行配置;</p>
<pre><code> gtid_mode=on
 enforce_gtid_consistency=on
 log_bin=on
 server_id=单独设置一个
 binlog_format=row
 接着在从库进行配置：
 gtid_mode=on
 enforce_gtid_consistency=on
 log_slave_updates=1
 server_id=单独设置一个

 接着按照之前讲解的步骤在主库创建好用于复制的账号之后，就可以跟之前一样进行操作了，比如在主库dump出来一
 份数据，在从库里导入这份数据，利用mysqldump备份工具做的导出，备份文件里会有SET
 @@GLOBAL.GTID_PURGED=***一类的字样，可以照着执行一下就可以了。
 接着其余步骤都是跟之前类似的，最后执行一下show master status，可以看到executed_gtid_set，里面记录的是执行
 过的GTID，接着执行一下SQL：select * from gtid_executed，可以查询到，对比一下，就会发现对应上了。
 那么此时就说明开始GTID复制了

其实大家会发现无论是GTID复制，还是传统复制，都不难，很简单，往往这就是比较典型的MySQL主从复制的搭建方
式了，然后大家可以自行搜索一下MyCat中间件或者是Sharding-Sphere的官方文档，其实也都不难，大家照着文档
做，整合到Java代码里去，就可以做出来基于主从复制的读写分离的效果了。
那些中间件都是支持读写分离模式的，可以仅仅往主库去写，从从库去读，这都没问题的。
如果落地到项目里，那么就完成了一个主从架构以及读写分离的架构了，此时按照我们之前所说的，如果说你的数据
库之前对一个库的读写请求每秒总共是2000，此时读写分离后，也许就对主库每秒写TPS才几百，从库的读QPS是
1000多。
那么万一你要是从库的读QPS越来越大，达到了每秒几千，此时你是不是会压力很大？没关系，这个时候你可以给主
库做更多的从库，搭建从库，给他挂到主库上去，每次都在凌晨搞，先让系统停机，对外不使用，数据不更新。
接着对主库做个dump，导出数据，到从库导入数据，做一堆配置，然后让从库开始接着某个时间点开始继续从主库复
制就可以了，一旦搭建完毕，就等于给主库挂了一个新的从库上去，此时继续放开系统的对外限制，继续使用就可以
了，整个过程基本在1小时以内。
如果在凌晨比如2点停机1小时，基本对业务是没有影响的。
</code></pre>
<h4 id="主从复制数据延迟问题">主从复制数据延迟问题</h4>
<p>为什么会产生主从延迟问题？</p>
<pre><code>其实很简单，其实你主库是多线程写入的，速度很快，从库是单个线程缓慢拉去数据，所以才会导致从库的复制数据的速度是比较慢的
</code></pre>
<p>主从复制的延迟实践监控</p>
<pre><code>这个可以用一个工具进行监控，比较推荐的是percona-toolkit工具集里的pt-hearbeat工具，他会在主库创建一个hearbeat表，
然后会有一个线程定时更新这个表里的时间戳字段，从库上就会有一个monitor线程会负责检查从库同步过来的hearbeat表里的时间戳。
把时间戳和当前时间对比一下就知道
</code></pre>
<p>如何缩小主从同步的延迟时间？</p>
<pre><code>其实就是让从库也用多线程并行复制数据就可以了，这样从库复制的速度很快，延迟就会很低了。
mysql5.7就已经支持并行复制了，可以在从库里设置slave_parallel_workers &gt;0,
然后把slave_parallel_type设为LOGICAL——CLOCK。
</code></pre>
<h4 id="高可用架构">高可用架构</h4>
<p>主从复制说白了就是允许主库把数据复制到从库上，然后允许我们的系统往主库里写数据，从库里读数据，实现一个读写分离的模式。</p>
<p>那么读写分离的模式确定了，接着就可以考虑一下数据库的高可用架构了，所谓的高可用架就是说数据库突然宕机，比如说主库或者从库宕机了，那么数据库还能正常使用吗？</p>
<p>如果主库真的宕机了，那就真的麻烦了，因为主库一旦宕机，你就没法写入数据，从库毕竟是不允许写入数据的，只允许读取。</p>
<p>所以数据库的高可用架构，可以实现主库宕机的同时，把从库切换为主库，然后所有的请求都基于现在的这台服务器去经行去读和写入。，</p>
<p>一般生产环境用于数据库高可用架构额管理工具MHA，是日本人写的，用peer脚本写一个工具，这个工具就是战门用于监控主库的状态，如果</p>
<p>感觉不对，就可以把从库切换为从库。</p>
<p>这个MHA也是需要单独部署的，分为两种节点，一个是Manager节点，一个是Node节点，Manager节点一般都是单独部署一台机器的<br>
Node节点一般都是部署在每天Mysql机器上的，因为Node节点通过通过解析各个Mysql的日志来进行一些操作</p>
<p>Manager节点会通过探测集群里的Node节点去判断各个Node所在机器上的MySQL运行是否正常，如果发现某个Master故障，就直接把Slave提升为Master，然后让<br>
其他Slave都挂到新的Master上去，完全透明。</p>
<h4 id="分库分表">分库分表</h4>
<p>要实现分库分表需要数据库中间件支持的，业内常用的一般有Sharding-Sphere以及Mycat两种，都是国内开源的。</p>
<p>一般建议Mysql单表数据量不超过1000万，最好在500万以内，如果内控制在100万以内，那是最佳的选择了，单表控制在100万以内，性能上不会有太大的问题，<br>
前提是你要建立好所有就行，其实保证Mysql高性能通常没有什么高深的技巧，就是控制数据量不要太大，另外只要保证你的查询用上了索引，所以一般就不会有问题。</p>
<p>一般分库分表时往往要考虑三个维度：<br>
1.一个是必然要按照主键id为粒度去分库分表，也就是把主键id进行hash后，对表数量进行取模，然后把数据均匀的分布到这些表中，<br>
再把这些表分散到多台数据库里。<br>
2.另外两个维度是用户端和运营端<br>
用户端：用户可能要查询自己的订单<br>
运营端：公司可能要查询所有的订单<br>
如何解决，针对用户端，你就需要按照(userids，主键id)这个表结构去做一个索引映射表，</p>
<p>userid和主键id的一一对应映射关系要放到这个表里，然后针对userid为粒度取进行分表分库</p>
<p>也就是对userid进行hash后取模，然后把数据均匀分散到很多索引映射表，再把表放到很多数据库里。</p>
<p>然后每次用户端拿出app查询自己的订单，直接根据userid取hash后取模路由到一个索引映射表，找到用户的userid</p>
<p>这里当然可以做一个分页了，先拿到所有的主键id，再根据主键id取对应的数据库里，去分库分表的表里提取完整数据。</p>
<p>至于运营端，一般都是根据N多个条件对数据经行搜索，此时跟上次将的一样，可以把数据的搜索条件放到es里面</p>
<p>然后用es来进行复杂搜索，找出一波主键id，再根据主键id去分库分表里找到完整数据。</p>
<p>分库分表的玩法基本都是这套思路，按业务id分库分表，建立索引映射表的同时进行分库分表，数据同步到es做复杂搜索，</p>
<p>基本这套玩法就可以保证你的分库分表的场景下，各种业务都可以执行</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#mysql">mysql</a>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
</ul>
</li>
<li><a href="#%E7%9B%AE%E5%BD%95-2">目录</a>
<ul>
<li><a href="#mysql%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84">Mysql基础架构</a>
<ul>
<li><a href="#mysql%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">Mysql架构设计</a></li>
<li><a href="#innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">InnoDB存储引擎的架构设计</a>
<ul>
<li><a href="#buffer-pool">buffer pool</a></li>
<li><a href="#redo-log">redo log</a></li>
<li><a href="#undo-log">undo log</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E5%8A%A1">事务</a>
<ul>
<li><a href="#%E5%A4%9A%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E6%88%96%E8%80%85%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98">多事务并发更新或者查询的数据问题</a>
<ul>
<li><a href="#%E8%84%8F%E5%86%99">脏写</a></li>
<li><a href="#%E8%84%8F%E8%AF%BB">脏读</a></li>
<li><a href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">不可重复读</a></li>
<li><a href="#%E5%B9%BB%E8%AF%BB">幻读</a></li>
</ul>
</li>
<li><a href="#sql%E6%A0%87%E5%87%86%E4%B8%AD%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%844%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">SQL标准中对事务的4个隔离级别</a>
<ul>
<li><a href="#read-uncommitted-%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%E6%98%AF%E4%B8%8D%E5%85%81%E8%AE%B8%E8%84%8F%E5%86%99%E7%9A%84">read uncommitted 读未提交：是不允许脏写的</a></li>
<li><a href="#read-committed-rc-%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%E8%84%8F%E5%86%99%E5%92%8C%E8%84%8F%E8%AF%BB">read committed  RC 读已提交：不可能发生脏写和脏读</a></li>
<li><a href="#repeatable-read-rr-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%E8%84%8F%E8%AF%BB%E8%84%8F%E5%86%99%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">repeatable read RR 可重复读：不可能发生脏读脏写，不可重复读</a></li>
<li><a href="#serializable-%E4%B8%B2%E8%A1%8C%E5%8C%96">serializable 串行化</a></li>
</ul>
</li>
<li><a href="#spring%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81">spring对事务的支持</a></li>
<li><a href="#%E9%80%8F%E5%BD%BB%E5%89%96%E6%9E%90mysql%E7%9A%84mvcc%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6">透彻剖析Mysql的MVCC事务隔离机制</a>
<ul>
<li><a href="#undo-log%E7%89%88%E6%9C%AC%E9%93%BE">Undo log版本链</a></li>
<li><a href="#readview%E6%9C%BA%E5%88%B6">ReadView机制</a></li>
<li><a href="#read-committed%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Ereadview%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%9A%84">Read Committed隔离级别是如何基于ReadView机制实现的？</a></li>
<li><a href="#mysql%E6%9C%80%E7%89%9B%E7%9A%84rr%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Ereadview%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%9A%84">MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E4%B8%AA%E4%BA%8B%E5%8A%A1%E6%9B%B4%E6%96%B0%E5%90%8C%E4%B8%80%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%97%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E9%94%81%E9%81%BF%E5%85%8D%E8%84%8F%E5%86%99%E7%9A%84">多个事务更新同一行数据时，是如何加锁避免脏写的？</a>
<ul>
<li><a href="#%E5%85%B1%E4%BA%AB%E9%94%81">共享锁</a></li>
<li><a href="#%E7%8B%AC%E5%8D%A0%E9%94%81">独占锁</a></li>
</ul>
</li>
<li><a href="#%E5%9C%A8%E8%A1%A8%E7%BA%A7%E5%88%AB%E5%8A%A0%E9%94%81">在表级别加锁</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95">索引</a>
<ul>
<li><a href="#%E7%A3%81%E7%9B%98%E4%B8%8A%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">磁盘上数据页的存储结构</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B5%E5%88%86%E8%A3%82%E7%9A%84%E8%BF%87%E7%A8%8B">页分裂的过程</a></li>
<li><a href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95">主键索引</a></li>
<li><a href="#b%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%B4%A2%E5%BC%95%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">B+树实现索引的物理结构</a></li>
<li><a href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">聚簇索引</a></li>
<li><a href="#%E9%92%88%E5%AF%B9%E4%B8%BB%E9%94%AE%E4%B9%8B%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86">针对主键之外的其他字段建立索引的原理</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">索引的优缺点</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99">索引的使用规则</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%99">索引的设计规则</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">执行计划</a></li>
<li><a href="#sql%E8%B0%83%E4%BC%98">Sql调优</a></li>
</ul>
</li>
<li><a href="#mysql%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8">mysql物理存储</a>
<ul>
<li><a href="#varchar%E8%BF%99%E7%A7%8D%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84">VARCHAR这种变长字段，在磁盘上到底是如何存储的</a></li>
<li><a href="#%E4%B8%80%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AAnull%E5%AD%97%E6%AE%B5%E5%80%BC%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8">一行数据中的多个NULL字段值在磁盘上怎么存储</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E4%B8%AD40%E4%B8%AAbit%E4%BD%8D%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%B4%E4%BB%A5%E5%8F%8A%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84">磁盘文件中40个bit位的数据头以及真实数据是如何存储的</a></li>
<li><a href="#%E4%B8%80%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%99%85%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E7%9A%84%E5%AD%98%E5%82%A8">一行数据实际在磁盘上的存储</a></li>
<li><a href="#%E8%A1%8C%E6%BA%A2%E5%87%BA">行溢出</a></li>
<li><a href="#%E8%A1%A8%E7%A9%BA%E9%97%B4">表空间</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5">生产实践</a>
<ul>
<li><a href="#%E7%9C%9F%E5%AE%9E%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%BA%E5%99%A8%E9%85%8D%E7%BD%AE%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92">真实生产环境下的数据库机器配置如何规划</a></li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84">互联网公司的生产环境数据库是如何进行性能测试的？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C360%E5%BA%A6%E6%97%A0%E6%AD%BB%E8%A7%92%E5%8E%8B%E6%B5%8Bhttpsapppukyptrl1086pcxiaoe-techcomdetaili_5e383c5357307_mjhluwmb1fromp_5e0c2a35dbbc9_mndgdybatype6">如何对生产环境中的数据库进行360度无死角压测？（https://apppukyptrl1086.pc.xiaoe-tech.com/detail/i_5e383c5357307_MjhluwMb/1?from=p_5e0c2a35dbbc9_MNDGDYba&amp;type=6）</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%A4%9A%E4%B8%AAbuffer-pool%E6%9D%A5%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD">如何通过多个Buffer Pool来优化数据库的并发性能</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87chunk%E6%9D%A5%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E7%9A%84buffer-pool%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4">如何通过chunk来支持数据库运行期间的Buffer Pool动态调整</a></li>
<li><a href="#%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E9%85%8D%E7%BD%AE%E6%9D%A5%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AEbuffer-pool">在生产环境中，如何基于机器配置来合理设置Buffer Pool</a></li>
<li><a href="#linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%B1%82%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8Aio%E8%B0%83%E5%BA%A6%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86">Linux操作系统的存储系统软件层原理剖析以及IO调度优化原理</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84raid%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E5%88%9D%E6%AD%A5%E4%BB%8B%E7%BB%8D">数据库服务器使用的RAID存储架构初步介绍</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84raid%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%94%B5%E6%B1%A0%E5%85%85%E6%94%BE%E7%94%B5%E5%8E%9F%E7%90%86">数据库服务器上的RAID存储架构的电池充放电原理</a></li>
<li><a href="#raid%E9%94%82%E7%94%B5%E6%B1%A0%E5%85%85%E6%94%BE%E7%94%B5%E5%AF%BC%E8%87%B4%E7%9A%84mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E6%8A%96%E5%8A%A8%E7%9A%84%E4%BC%98%E5%8C%96">RAID锂电池充放电导致的MySQL数据库性能抖动的优化</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%95%85%E9%9A%9C%E7%9A%84%E5%AE%9A%E4%BD%8Dtoomanyconnections">数据库无法连接故障的定位TooManyConnections</a></li>
<li><a href="#%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E6%80%A7%E8%83%BD%E6%8A%96%E5%8A%A8%E4%BC%98%E5%8C%96">线上数据库不确定性的性能抖动优化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84">mysql主从架构</a>
<ul>
<li><a href="#%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8E%9F%E7%90%86">主从架构的原理</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA%E6%9C%80%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84">主从复制架构的搭建(最基础架构)</a><br>
*
<ul>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%8D%8A%E5%A4%8D%E5%88%B6%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5">主从半复制（生产实践）</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98">主从复制数据延迟问题</a></li>
<li><a href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84">高可用架构</a></li>
<li><a href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">分库分表</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://zuolinlin.github.io/zuo.github.io/post/idea-zhao-bu-dao-fu-hao/">
              <h3 class="post-title">
                idea 找不到符号
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">zuozuozuo</a>
  <a class="rss" href="https://zuolinlin.github.io/zuo.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
